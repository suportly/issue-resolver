"""PR creation and template handling."""

from __future__ import annotations

import logging
from pathlib import Path

from issue_resolver.github.client import run_gh
from issue_resolver.models.analysis import Analysis
from issue_resolver.models.issue import Issue

logger = logging.getLogger(__name__)


def create_pr(
    owner: str,
    repo: str,
    head_branch: str,
    title: str,
    body: str,
    issue_number: int | None = None,
) -> str:
    """Create a pull request via gh CLI.

    Args:
        owner: Target repo owner.
        repo: Target repo name.
        head_branch: Source branch (format: "user:branch").
        title: PR title.
        body: PR body markdown.
        issue_number: Issue number to reference.

    Returns:
        URL of the created PR.
    """
    logger.info("Creating PR: %s", title)

    args = [
        "pr",
        "create",
        "--repo",
        f"{owner}/{repo}",
        "--head",
        head_branch,
        "--title",
        title,
        "--body",
        body,
    ]

    output = run_gh(args, timeout=30)
    pr_url = output.strip()
    logger.info("PR created: %s", pr_url)
    return pr_url


def build_pr_body(
    issue: Issue,
    analysis: Analysis,
    diff_summary: str | None,
    test_output: str | None,
    cost_usd: float,
    is_untested: bool = False,
) -> str:
    """Build a PR body with issue reference and analysis details.

    Args:
        issue: The target issue.
        analysis: The solvability analysis.
        diff_summary: Git diff stat summary.
        test_output: Test runner output (truncated).
        cost_usd: Total cost of the resolution.
        is_untested: Whether no test suite was found.

    Returns:
        Formatted PR body markdown.
    """
    sections = [
        "## Summary\n",
        f"Fixes #{issue.number}\n",
        f"This PR addresses the issue: **{issue.title}**\n",
        "### Analysis\n",
        f"- **Solvability**: {analysis.rating.value} (confidence: {analysis.confidence:.0%})",
        f"- **Complexity**: {analysis.complexity or 'unknown'}",
        f"- **Reasoning**: {analysis.reasoning}\n",
    ]

    if diff_summary:
        sections.append(f"### Changes\n\n```\n{diff_summary}\n```\n")

    if test_output:
        # Truncate test output to keep PR readable
        truncated = test_output[:2000]
        if len(test_output) > 2000:
            truncated += "\n... (truncated)"
        sections.append(f"### Test Results\n\n```\n{truncated}\n```\n")

    if is_untested:
        sections.append(
            "### Note\n\n"
            "No test suite was detected for this project. "
            "The fix has been applied but could not be automatically verified. "
            "Please review carefully.\n"
        )

    sections.append(
        f"---\n"
        f"*Generated by [issue-resolver](https://github.com/suportly/issue-resolver) "
        f"| Cost: ${cost_usd:.2f}*"
    )

    return "\n".join(sections)


def read_pr_template(workspace_path: str) -> str | None:
    """Read the PR template from a repository if it exists.

    Checks common locations for PR templates.
    """
    root = Path(workspace_path)
    template_locations = [
        root / ".github" / "pull_request_template.md",
        root / ".github" / "PULL_REQUEST_TEMPLATE.md",
        root / "pull_request_template.md",
        root / "PULL_REQUEST_TEMPLATE.md",
        root / ".github" / "PULL_REQUEST_TEMPLATE" / "default.md",
    ]

    for path in template_locations:
        if path.is_file():
            try:
                return path.read_text()
            except OSError:
                continue

    return None


def read_contributing_md(workspace_path: str) -> str | None:
    """Read CONTRIBUTING.md from a repository if it exists."""
    root = Path(workspace_path)
    locations = [
        root / "CONTRIBUTING.md",
        root / "contributing.md",
        root / ".github" / "CONTRIBUTING.md",
    ]

    for path in locations:
        if path.is_file():
            try:
                return path.read_text()
            except OSError:
                continue

    return None
